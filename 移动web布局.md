### 移动web布局

#### 移动端基础

##### 浏览器现状

PC端常见浏览器：360浏览器、谷歌浏览器、火狐浏览器、QQ浏览器、百度浏览器、搜狗浏览器、IE浏览器。

移动端常见浏览器：UC浏览器、QQ浏览器、欧朋浏览器、百度手机浏览器、360浏览器、谷歌浏览器、搜狗手机浏览器、猎豹浏览器等。

国内的UC和QQ，百度等手机浏览器都是根据Webkit修改过来的内核，国内尚无自主研发的内核。

**总结：兼容移动端主流浏览器，处理Webkit内核浏览器即可。**

##### 手机屏幕的现状

移动端设备屏幕尺寸非常多，碎片化严重。

Android设备有多种分辨率；近年来iPhone的碎片化也加剧了。

##### 移动端调试方法

- Chrome DevTools(谷歌浏览器)的模拟手机调试
- 搭建本地web服务器，手机和服务器一个局域网内，通过手机访问服务器
- 使用外网服务器，直接IP或域名访问

#### 视口

视口（viewport）就是浏览器显示页面内容的屏幕区域。视口可以分为布局视口、视觉视口和理想视口

##### 布局视口layout viewport

一般移动设备的浏览器都默认设置了一个布局视口，用于解决早期的PC端页面在手机上显示的问题。

iOS,Android基本都将这个视口分辨率设置为980px,所以PC上的网页大多都能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页。

##### 视觉视口visual viewport：

它是用户正在看到的网站的区域。

我们可以通过缩放取操作视觉视口，但不会影响布局视口，布局视口仍保持原来的宽度。

##### 理想视口ideal viewport

为了使网站在移动端有最理想的浏览和阅读宽度而设定。

理想视口，对设备来讲，是最理想的视口尺寸。

需要手动添写meta视口标签通知浏览器操作。

meta视口标签的主要目的：布局视口的宽度应该与理想视口的宽度一致，简单理解就是设备有多宽，我们布局的视口就多宽。

**总结：我们开发最终会用理想视口，而理想视口就是将布局视口的宽度修改为视觉视口。**

##### meta标签

```js
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0">
```

| 属性          | 解释说明                                             |
| ------------- | ---------------------------------------------------- |
| width         | 宽度设置的是viewport宽度，可以设置device-width特殊值 |
| initial-scale | 初始缩写比，大于0的数字                              |
| maximum-scale | 最大缩写比，大于0的数字                              |
| minimum-scale | 最小缩写比，大于0的数字                              |
| user-scalable | 用户是否可以缩放，yes或no(1或0)                      |

最标准的viewport设置

- 视口宽度和设备保持一致
- 视口的默认缩放比例1.0
- 不允许用户自行缩放
- 最大允许的缩放比例1.0
- 最小允许的缩放比例1.0

#### 二倍图

**物理像素&物理像素比**

物理像素点指的是屏幕显示的最小颗粒，是物理真实存在的。这是厂商在出厂时就设置好了,比如苹果6 是 750* 1334 。

我们开发时候的1px 不是一定等于1个物理像素的

一个px的能显示的物理像素点的个数，称为物理像素比或屏幕像素比

如果把1张100*100的图片放到手机里面会按照物理像素比给我们缩放

lRetina（视网膜屏幕）是一种显示技术，可以将把更多的物理像素点压缩至一块屏幕里，从而达到更高的分辨率，并提高屏幕显示的细腻程度。

对于一张 50px * 50px 的图片,在手机或 Retina 屏中打开，按照刚才的物理像素比会放大倍数，这样会造成图片模糊

在标准的viewport设置中，使用倍图来提高图片质量，解决在高清设备中的模糊问题

通常使用二倍图， 因为iPhone 6 的影响背景图片 注意缩放问题

##### 背景缩放background-size

```js
background-size:背景图片宽度 背景图片高度；
```

单位：长度、百分比、cover、contain；

cover把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。

contain把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域 

#### 移动开发选择和技术解决方案

##### 移动端主流方案

1. 单独制作移动端页面（主流）

   通常情况下，网址域名前面加m(moblile)可以打开移动端，通过判断设备，如果是移动设备打开，则跳到移动端页面。

   也就是说，PC端和移动端为两套网站，pc端是pc端的样式，移动端在写一套，专门针对移动端适配的一套网站。

2. 响应式页面兼容移动端（其次）

   响应式网站：即pc和移动端共用一套网站，只不过在不同屏幕下，样式会自动适配。

##### 移动技术解决方案

1. 移动端浏览器兼容问题

   移动端浏览器基本以webkit内核为主，因此我们就考虑webkit兼容性问题。

   我们可以放心使用H5标签和CSS3样式。同时我们浏览器的私有前缀我们只需要考虑加webkit即可。

2. 移动端公共样式

   移动端CSS初始化推荐使用normalize.css/

   Normalize.css:保护了有价值的默认值

   Normalize.css:修复了浏览器的bug

   Normalize.css:是模块化的

   Normalize.css:拥有详细的文档

   官网地址： <http://necolas.github.io/normalize.css/> 

##### 移动端大量使用CSS3盒子模型box-sizing

传统模式宽度计算：盒子的宽度=CSS中设置的width+border+padding

CSS3盒子模型：盒子的宽度=CSS中设置的宽度width里面包含了border和padding；也就是说，我们的CSS3中的盒子模型，padding和border不会撑大盒子了

```js
//css3盒子模型
box-sizing:border-box;
//传统盒子模型
box-sizing:content-box;
```

移动端可以全部css3盒子模型

PC端如果完全需要兼容，我们就用传统模式，如果不考虑兼容性，我们就选择css3盒子模型

##### 移动端特殊样式

```js
//css3盒子模型
box-sizing:border-box;
-webkit-box-sizing:border-box;
//点击高亮我们需要清除清除 设置为ransparent完成透明
-webkit-tap-highlight-color:transparent;
//在移动端浏览器默认的外观在iOS上加上这个属性才能给按钮和输入框自定义样式
-webkit-appearance:none;
//禁用长按页面时的弹出菜单
img,a{ -webkit-touch-callout:none;}
```

#### 移动端常见布局

移动端单独制作

- 流式布局（百分比布局）
- flex弹性布局（强烈推荐）
- less+rem+媒体查询布局
- 混合布局

响应式

- 媒体查询
- bootstarp

流式布局：

通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充。

流式布局方式是移动web开发使用的比较常见的布局方式。

#### 移动web开发——flex布局

##### 传统布局和flex布局对比

传统布局：

- 兼容性好
- 布局繁琐
- 局限性，不能在移动端很好的布局

flex布局：

- 操作方便，布局极其简单，移动端使用比较广泛
- pc端浏览器支持情况比较差
- IE11或更低版本不支持flex或仅支持部分

建议：

- 如果是pc端页面布局，还是采用传统方式
- 如果是移动端或者不考虑兼容的pc则采用flex

##### flex布局原理

- flex是flexible Box的缩写，意为“弹性布局”，用来为盒状模型提供更大的灵活性，任何一个容器都可以指定为flex布局
- 当我们为父盒子设为flex布局以后，子元素的float、clear和vertical-align属性将失效
- flex布局又叫伸缩布局、弹性布局、伸缩盒布局、弹性盒布局
- 采用Flex布局的元素，称为Flex容器。它的所有子元素自动称为容器成员，称为Flex项目，简称'项目'

**总结：**就是通过给父盒子添加flex属性，来控制子盒子的位置盒排列方式

#### 父项常见属性

- flex-direction:设置主轴的方向
- justify-content:设置主轴上的子元素排列方式
- flex-wrap:设置子盒子是否换行
- align-content:设置侧轴上的子元素的排列方式（多行）
- align-items:设置侧轴上的子元素排列方式（单行）
- flex-flow:复合属性，相当于同时设置了flex-direction和flex-wrap

##### flex-direction设置主轴的方向

- 在flex布局中，是分为主轴和侧轴两个方向，同样的叫法有：行和列、x轴和y轴

- 默认主轴方向就是x轴方向，水平向右

- 默认侧轴方向就是y轴方向，水平向下

- 注意：主轴和侧轴是会变化的，就看flex-direction设置谁为主轴，剩下的就是侧轴。而我们的子元素是跟着主轴来排列的

  | row            | 默认值从左到右 |
  | -------------- | -------------- |
  | row-reverse    | 从右到左       |
  | column         | 从上到下       |
  | column-reverse | 从下到上       |

##### justify-content设置主轴上的子元素排列方式

| flex-start    | 默认值 从头部开始 如果主轴是x轴，则从左到右 |
| ------------- | ------------------------------------------- |
| flex-end      | 从尾部开始排列                              |
| center        | 在主轴居中对齐（如果主轴是x轴则水平居中）   |
| space-around  | 平分剩余空间                                |
| space-between | 先两边贴边 再平分剩余空间（重要）           |

##### flex-wrap设置是否换行

- 默认情况下，项目都排在一条线（又称“轴线”）上。flex-wrap属性定义，flex布局中默认是不换行的。
- nowrap不换行
- wrap换行

##### align-items设置侧轴上的子元素排列方式（单行）

- 该属性是控制子项在侧轴（默认是y轴）上的排列方式 在子项为单项（单行）的时候使用
- flex-start从头部开始
- flex-end从尾部开始
- center居中显示
- stretch拉伸

##### align-content设置侧轴上的子元素的排列方式（多行）

设置子项在侧轴上的排列方式 并且只能用于子项出现换行的情况（多行），在单行下是没有效果的。

| flex-start    | 默认值在侧轴的头部开始排列             |
| ------------- | -------------------------------------- |
| flex-end      | 在侧轴的尾部开始排列                   |
| center        | 在侧轴中间显示                         |
| space-around  | 子项在侧轴平分剩余空间                 |
| space-between | 子项在侧轴先分布在两头，再平分剩余空间 |
| stretch       | 设置子项元素高度平分父元素高度         |

##### align-content和align-items区别

- align-items适用于单行情况下，只有上对齐、下对齐、居中和拉伸
- align-content适应于换行（多行）的情况下（单行情况下无效），可以设置上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性值。
- 总结就是单行找align-items多行找align-content

##### flex-flow属性是flex-direction和flex-wrap属性的复合属性

```js
flex-flow:row wrap;
```

#### flex布局子项常见属性

- flex子项目占的份数
- align-self控制子项自己在侧轴的排列方式
- order属性定义子项的排列顺序（前后顺序）

##### flex属性

flex属性定义子项目分配剩余空间，用flex来表示占多少份数

```js
.item{
    flex:<number>;//默认值0
}
```

##### align-self控制子项自己在侧轴上的排列方式

align-self属性允许当项目有与其他项目不一样的对齐方式，可覆盖align-items属性。

默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。

```js
span:nth-child(2){
    //设置自己在侧轴上的排列方式
    align-self:flex-end;
}
```

##### order属性定义项目的排列顺序

数值越小，排列越靠前，默认为0。

注意：和z-index不一样

```js
.item{
    order:<number>;
}
```

#### 移动web开发之rem布局

##### rem基础

rem是一个相对单位，类似于em,em是父元素字体大小。

不同的是rem的基准是相对于html元素的字体大小。

比如，跟元素（html)设置font-size=12px;非根元素设置width：2rem;则换成px表示就是24px.

```js
//跟html为12px
html{
    font-size:12px;
}
//此时div的字体大小就是24px
div{
    font-size:2rem;
}
```

rem的优势：父元素文字大小可能不一致，但是整个页面只有一个html，可以很好来控制整个页面的元素大小。

#### 媒体查询

##### 什么是媒体查询

媒体查询（Media Query)是CSS3新语法。

- 使用@media查询，可以针对不同的媒体类型定义不同的样式
- @media可以针对不同的屏幕尺寸设置不同的样式
- 当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面
- 目前针对很多苹果手机、Android手机，平板等设备都用得到多媒体查询

##### 媒体查询语法规范

- 用@media开头 注意@符号
- mediatype媒体类型
- 关键字and not only
- media feature媒体特性必须有小括号包含

```js
@media mediatype and|not|only (media feature){
    CSS-Code;
}
```

##### mediatype查询类型

将不同的终端设备划分成不同的类型，称为媒体类型

| 值        | 解释说明                               |
| --------- | -------------------------------------- |
| all       | 用于所有设备                           |
| print     | 用于打印机和打印预览                   |
| ==scree== | ==用于电脑屏幕，平板电脑，智能手机等== |

##### 关键字

关键字将媒体类型或多个媒体特性连接到一起做为媒体查询的条件

- and:可以将多个媒体特性连接到一起，相当于“且”的意思
- not:排除某个媒体类型，相当于“非”的意思，可以省略
- only:指定某个特定的媒体类型，可以省略

##### 媒体特性

每种媒体类型都具体各自不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格。

注意她们要加小括号包含

| 值        | 解释说明                           |
| --------- | ---------------------------------- |
| width     | 定义输出设备中页面可见区域的宽度   |
| min-width | 定义输出设备中页面最小可见区域宽度 |
| max-width | 定义输出设备中页面最大可见区域宽度 |

##### 媒体查询书写规则

注意：为了防止混乱，媒体查询我们要按照从小到大或者从大到小的顺序来写，但是我们最喜欢的还是从小到大来写，这样代码更简洁。

#### less基础

##### 维护css弊端

css是一门非程序式语言，没有变量、函数、SCOPE（作用域）等概念。

- css需要书写大量看似没有逻辑的代码，CSS冗余度是比较高的
- 不方便维护及扩展，不利于复用
- css没有很好的计算能力
- 非前端开发工程师来讲，往往会因为缺少css编写经验而很难写出组织良好且易于维护的css代码项目

##### less介绍

less(LeanerStyle Sheets的缩写)是一门css扩展语言，也成为css预处理器。

作为css的一种形式的扩展，它并没有减少css的功能，而是在现有css语法上，为css加入程序式语言的特性。

它在css的语法基础上，引入了变量，Mixin(混入)，运算以及函数等功能，大大简化了css的编写，并且降低了css的维护成本，就像它的名称所说的那样，Less可以让我们用更少的代码做更多的事情。

Less中文网址：：[Less 中文网 (lesscss.cn)](http://lesscss.cn/) 

常见的css预处理器：Sass、Less、Stylus

Less是一门css预处理语言，它扩展了CSS的动态特性。

**Less安装**

①安装nodejs，可选择版本(8.0)，网址：[http://nodejs.cn/download/(opens new window)](http://nodejs.cn/download/)

②检查是否安装成功，使用cmd命令（win10是window+r 打开运行输入cmd） ---输入“node –v”查看版本即可

③基于nodejs在线安装Less，使用cmd命令“npm install -g less”即可

④检查是否安装成功，使用cmd命令“ lessc -v ”查看版本即可

**Less使用之变量**

变量是指没有固定的值，可以改变的。因为我们CSS中的一些颜色和数值等经常使用。

```js
@变量名：值
```

- 必须有@为前缀
- 不能包含特殊字符
- 不能以数字开头
- 大小写敏感

```js
@color:pink;
```

Less 编译 vocode Less 插件

Easy LESS 插件用来把less文件编译为css文件

安装完毕插件，重新加载下 vscode。

只要保存一下Less文件，会自动生成CSS文件。

**Less嵌套**

```js
//将css改为less
#header .logo{
	width:300px;
}
#header{
    .logo{
        width:300px;
    }
}
```

如果遇见（交集|伪类|伪元素选择器），利用&进行连接

```js
a:hover{
    color:red;
}
a{
    &:hover{
        color:red;
    }
}
```

**Less运算**

任何数字、颜色或者变量都可以参与运算，就是Less提供了加、减、乘、除算术运算。

```js
//Less里面写
@width: 100px + 5;
div{
    border:@width solid red;
}
//生成的css
div{
    border:15px solid red;
}
//Less甚至还可以这样
width:(@width+5)*2;
```

- 对于两个不同的单位的值之间的运算，运算结果的值取第一个值的单位
- 如果两个值之间只有一个值有单位，则运算结果就取该单位

#### rem适配方案

1. 让一些不能等比自适应的元素，达到当设备尺寸发生改变的时候，等比例适配当前设备
2. 使用媒体查询根据不同设备按比例设置html的字体大小，然后页面元素使用rem做尺寸单位，当html字体大小变化元素尺寸也会发生变化，从而达到等比缩放的适配
3. 技术方案：
   - less+rem+媒体查询
   - lflexible.js+rem
4. 总结：两个方案现在都存在，方案2更简单，现阶段大家无需了解里面js代码。

**rem实际开发适配方案1**

①假设设计稿是750px

②假设我们把整个屏幕划分为15等份（划分标准不一可以是20份也可以是10等份）

③每一份作为html字体大小，这里就是50px

④那么在320px设备的时候，字体大小为320/15就是 21.33px

⑤用我们页面元素的大小除以不同的 html字体大小会发现他们比例还是相同的

⑥比如我们以750为标准设计稿

⑦一个100*100像素的页面元素在 750屏幕下， 就是 100/ 50 转换为rem 是 2rem*2rem 比例是1比1

⑧320屏幕下， html字体大小为21.33 则 2rem= 42.66px 此时宽和高都是 42.66 但是宽和高的比例还是 1比1

⑨但是已经能实现不同屏幕下 页面元素盒子等比例缩放的效果

总结：

①最后的公式：页面元素的rem值 = 页面元素值（px） / （屏幕宽度 / 划分的份数）

②屏幕宽度/划分的份数就是 htmlfont-size 的大小

③或者：页面元素的rem值 = 页面元素值（px） / html font-size 字体大小

**rem适配方案2**

手机淘宝团队出的简洁高效 移动端适配库

我们再也不需要在写不同屏幕的媒体查询，因为里面js做了处理

它的原理是把当前设备划分为10等份，但是不同设备下，比例还是一致的。

我们要做的，就是确定好我们当前设备的html 文字大小就可以了

比如当前设计稿是 750px， 那么我们只需要把 html 文字大小设置为 75px(750px / 10) 就可以

里面页面元素rem值： 页面元素的px 值 / 75

剩余的，让flexible.js来去算